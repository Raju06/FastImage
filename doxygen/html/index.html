<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Fast Image: Fast Image (FI) : A High-Performance Accessor for Processing Gigapixel Images</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Fast Image
   &#160;<span id="projectnumber">1.0.8</span>
   </div>
   <div id="projectbrief">Fast Image accessor for big images</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Fast Image (FI) : A High-Performance Accessor for Processing Gigapixel Images </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>An application programming interface to access big images</p>
<p>The API is designed to aid in creating image processing algorithms to obtain performance across CPUs and big images.</p>
<h2>Content</h2>
<ul>
<li><a href="#installation-instructions">Installation Instructions</a><ul>
<li><a href="#dependencies">Dependencies</a></li>
<li><a href="#building-fast-image">Building Fast Image</a></li>
</ul>
</li>
<li><a href="#motivation">Motivation</a></li>
<li><a href="#approach">Approach</a></li>
<li><a href="#architecture">Architecture</a></li>
<li><a href="#steps-to-programming-with-fast-image">Steps to Programming with Fast Image</a><ul>
<li><a href="#linking-_fast-image_">Linking Fast Image</a></li>
<li><a href="#api-overview">API overview</a></li>
<li><a href="#how-to-create-a-tile-loader-how-to-access-a-specific-file-">How to create a Tile Loader ? How to access a specific file ?</a></li>
<li><a href="#getting-started">Getting started</a><ul>
<li><a href="#image-traversal">Image traversal</a></li>
<li><a href="#spatial-convolution">Spatial convolution</a></li>
<li><a href="#opencv-convolution">OpenCV convolution</a></li>
<li><a href="#feature-collection-usage">Feature Collection usage</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#credits">Credits</a></li>
<li><a href="#contact-us">Contact Us</a></li>
</ul>
<h1>Installation Instructions</h1>
<h2>Dependencies</h2>
<p>1) g++/gcc version 4.8.4+</p>
<p>2) HTGS (<a href="https://github.com/usnistgov/htgs">https://github.com/usnistgov/htgs</a>)</p>
<p>3) LibTIFF (<a href="http://www.simplesystems.org/libtiff/">http://www.simplesystems.org/libtiff/</a>) [optional / TileLoader]</p>
<p>4) libpng (<a href="http://www.libpng.org/">http://www.libpng.org/</a>) [optional / TileLoader]</p>
<p>5) doxygen (www.doxygen.org/) [optional / Documentation]</p>
<h2>Building Fast Image</h2>
<p><b>CMake Options:</b></p>
<p>CMAKE_INSTALL_PREFIX - Where to install Fast Image (and documentation)</p>
<p>BUILD_DOXYGEN - Creates doxygen documentation</p>
<p>RUN_GTEST - Compiles and runs google unit tests for Fast Image ('make run-test' to re-run)</p>
<div class="fragment"><div class="line">:$ cd &lt;FastImage_Directory&gt;</div><div class="line">:&lt;FastImage_Directory&gt;$ mkdir build &amp;&amp; cd build</div><div class="line">:&lt;FastImage_Directory&gt;/build$ ccmake ../ (or cmake-gui)</div><div class="line"></div><div class="line">&#39;Configure&#39; and setup cmake parameters</div><div class="line">&#39;Configure&#39; and &#39;Build&#39;</div><div class="line"></div><div class="line">:&lt;FastImage_Directory&gt;/build$ make</div><div class="line">:&lt;FastImage_Directory&gt;/build$ [sudo] make install</div></div><!-- fragment --><h1>Motivation</h1>
<p>The hardware landscape for high-performance computing currently features compute nodes with a high degree of parallelism within a node (e.g., 46 cores for the newly-announced Qualcomm Centriq CPU, 32 physical cores for the AMD Epyc CPU, and 24 logical cores for an Intel Xeon Skylake CPU), that increases with every new hardware generation. By contrast, the amount of memory available per core is not increasing in a commensurate manner and may even be decreasing especially when considered on a per-core basis. Furthermore, while the computational capacity of these systems keeps on improving, their programmability remains quite challenging. As such, designing image processing algorithms to minimize memory usage is a key strategy to taking advantage of this parallelism and support concurrent users or the multi-threaded processing to large images.</p>
<h1>Approach</h1>
<p><em>Fast Image</em> improves programmer productivity by providing high-level abstractions, <em>View</em> and <em>Tile</em>, along with routines that build on these abstractions to operate across an entire image without actually loading it in memory. The library operates on tiles (e.g., a 1024x1024 partial image out of a very large 100K x 100K image) with possibly a halo of pixels around an individual tile. <em>Fast Image</em> only loads a small number of tiles to maintain a low-memory footprint and manages an in-memory cache. Furthermore, the library takes advantage of multi-core computing by offloading tiles to compute threads as soon as they become available. This allows for multiple users to maintain high throughput, while processing several images or views concurrently.</p>
<h1>Architecture</h1>
<p><em>Fast Image</em> architecture shows how the system work and interact with the algorithm. First of all it works asynchronously from the algorithm. Secondly each part of Fast Image will be on on different threads. Finally the static memory manager guaranty that the amount of memory will be limited as asked.</p>
<p>When an algorithm will ask <em>n</em> views through <em>View Request</em>. <em>Fast Image</em> will use this <em>View Request</em> to build a <em>view</em> and make it available as soon as possible. The algorithm will be able to use it (and release it). In the mean time, if enough memory is available an other <em>view</em> will be created.</p>
<p>The <em>View</em> creation go through 3 steps:</p><ol type="1">
<li><em>View Loader</em>: Request memory from the memory manager and split the <em>View Request</em>, to <em>n</em> <em>Tile Loader</em> and send them to the <em>Tile Loader</em>.</li>
<li><em>Tile Loader</em>: Specific to the file <em>Fast Image</em> access to. Will ask the <em>Tile</em> to <em>Tile Cache</em>, if it not available the <em>Tile</em> will be loaded from the file, then cast and copy to the <em>Tile Cache</em>. From the cache only the interesting <em>Tile</em>'s part will be copied to the <em>View</em>.</li>
<li><em>View Counter</em>: Wait to the <em>view</em> to be fully loaded from file's parts. Then build the ghost region if needed, and send the complete <em>view</em> to the algorithm.</li>
</ol>
<p>Following the Fast Image Graph and it's interaction with the algorithm:</p>
<div class="image">
<img src="FIGraph.png" alt="FIGraph.png"/>
<div class="caption">
Fast Image Graph</div></div>
 <h1>Steps to Programming with Fast Image</h1>
<h2>Linking <em>Fast Image</em></h2>
<p><em>Fast Image</em> can be easily link to any C++ 11 compliant code using cmake. Add the path to the folder FastImageDirectory/cmake-modules/ to the CMAKE_MODULE_PATH variable in your CMakeLists.txt. Then add the following lines in your CMakeLists.txt: </p><div class="fragment"><div class="line">find_package(FastImage REQUIRED)</div><div class="line">include_directories(${HTGS_INCLUDE_DIR})</div><div class="line">include_directories(${FastImage_INCLUDE_DIR})</div><div class="line">link_libraries(${FastImage_LIBRARIES})</div></div><!-- fragment --><h2>API overview</h2>
<p>3 API exists in <em>Fast Image</em>:</p><ol type="1">
<li>The FastImage object to access views of an image</li>
<li>The <em>View</em> object to access pixel/data in the <em>View</em></li>
<li>FeatureCollection to get the information on region of interests</li>
<li>Tile Loader</li>
</ol>
<h2>How to create a Tile Loader ? How to access a specific file ?</h2>
<p>To access to a new file format, a specific <em>Tile Loader</em> is needed. A specific <em>Tile Loader</em> class will inherit from the class <em>ATileLoader</em>.</p>
<p>The following methods need to be implemented: </p><div class="fragment"><div class="line"><span class="comment">// Constructor</span></div><div class="line">ATileLoader                       (<span class="keyword">const</span> std::string &amp;filePath, <span class="keywordtype">size_t</span> numThreads = 1);</div><div class="line"></div><div class="line"><span class="comment">// Copy function to duplicate the Tile Loader into n threads </span></div><div class="line">ATileLoader*  copyTileLoader      ();</div><div class="line"></div><div class="line"><span class="comment">// Task Name getter used for graph generation </span></div><div class="line">std::string   getName             ();</div><div class="line"></div><div class="line"><span class="comment">// Basic file information getter </span></div><div class="line">uint32_t      getImageHeight      (uint32_t level = 0) <span class="keyword">const</span>;</div><div class="line">uint32_t      getImageWidth       (uint32_t level = 0) <span class="keyword">const</span>;</div><div class="line">uint32_t      getTileWidth        (uint32_t level = 0) <span class="keyword">const</span>;</div><div class="line">uint32_t      getTileHeight       (uint32_t level = 0) <span class="keyword">const</span>;</div><div class="line"><span class="keywordtype">short</span>         getBitsPerSample    () <span class="keyword">const</span>;</div><div class="line">uint32_t      getNbPyramidLevels  () <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="comment">// Load a specific tile from the file, the tile has already allocated. Return the disk loading time in ms.</span></div><div class="line"><span class="keywordtype">double</span>        loadTileFromFile    (UserType *tile, uint32_t indexRowGlobalTile, uint32_t indexColGlobalTile);</div></div><!-- fragment --><p>Here a Tile Loader for Greyscale Tiled Tiff:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> UserType&gt;</div><div class="line"><span class="keyword">class </span>TiffTileLoader : <span class="keyword">public</span> ATileLoader&lt;UserType&gt; {</div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  TIFF *</div><div class="line">      _tiff = <span class="keyword">nullptr</span>;</div><div class="line"></div><div class="line">  uint32_t</div><div class="line">      _imageHeight = 0,</div><div class="line">      _imageWidth = 0,</div><div class="line">      _tileHeight = 0,</div><div class="line">      _tileWidth = 0;</div><div class="line"></div><div class="line">  <span class="keywordtype">short</span></div><div class="line">      _sampleFormat = 0,</div><div class="line">      _bitsPerSample = 0;</div><div class="line"></div><div class="line">  <span class="comment">// Copy Constructor used by copyTileLoader</span></div><div class="line">  TiffTileLoader(<span class="keywordtype">size_t</span> numThreads, <span class="keyword">const</span> std::string &amp;filePath, <span class="keyword">const</span> TiffTileLoader &amp;from)</div><div class="line">      : ATileLoader&lt;UserType&gt;(filePath, numThreads) {</div><div class="line">    this-&gt;_tiff = TIFFOpen(filePath.c_str(), <span class="stringliteral">&quot;r&quot;</span>);</div><div class="line">    this-&gt;_imageWidth = from._imageWidth;</div><div class="line">    this-&gt;_imageHeight = from._imageHeight;</div><div class="line">    this-&gt;_tileWidth = from._tileWidth;</div><div class="line">    this-&gt;_tileHeight = from._tileHeight;</div><div class="line">    this-&gt;_bitsPerSample = from._bitsPerSample;</div><div class="line">    this-&gt;_sampleFormat = from._sampleFormat;</div><div class="line">  }</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="comment">// Tile Loader constructor where the actual file is open</span></div><div class="line">  TiffTileLoader(<span class="keyword">const</span> std::string &amp;fileName, <span class="keywordtype">size_t</span> numThreads = 1) : ATileLoader&lt;UserType&gt;(fileName,</div><div class="line">                                                                                             numThreads) {</div><div class="line">    <span class="keywordtype">short</span> samplesPerPixel = 0;</div><div class="line"></div><div class="line">    this-&gt;_tiff = TIFFOpen(fileName.c_str(), <span class="stringliteral">&quot;r&quot;</span>);</div><div class="line">    <span class="keywordflow">if</span> (this-&gt;_tiff != <span class="keyword">nullptr</span>) {</div><div class="line">      <span class="keywordflow">if</span> (TIFFIsTiled(_tiff) == 0) {</div><div class="line">        std::stringstream message;</div><div class="line">        message &lt;&lt; <span class="stringliteral">&quot;Tile Loader ERROR: The image is not tiled.&quot;</span>;</div><div class="line">        <span class="keyword">auto</span> messageChr = <span class="keyword">new</span> <span class="keywordtype">char</span>[message.str().length() + 1];</div><div class="line">        strcpy(messageChr, message.str().c_str());</div><div class="line">        <span class="keywordflow">throw</span> (FastImageException(messageChr));</div><div class="line">      }</div><div class="line">      TIFFGetField(this-&gt;_tiff, TIFFTAG_IMAGEWIDTH, &amp;(this-&gt;_imageWidth));</div><div class="line">      TIFFGetField(this-&gt;_tiff, TIFFTAG_IMAGELENGTH, &amp;(this-&gt;_imageHeight));</div><div class="line">      TIFFGetField(this-&gt;_tiff, TIFFTAG_TILEWIDTH, &amp;this-&gt;_tileWidth);</div><div class="line">      TIFFGetField(this-&gt;_tiff, TIFFTAG_TILELENGTH, &amp;this-&gt;_tileHeight);</div><div class="line">      TIFFGetField(this-&gt;_tiff, TIFFTAG_SAMPLESPERPIXEL, &amp;samplesPerPixel);</div><div class="line">      TIFFGetField(this-&gt;_tiff, TIFFTAG_BITSPERSAMPLE, &amp;(this-&gt;_bitsPerSample));</div><div class="line">      TIFFGetField(this-&gt;_tiff, TIFFTAG_SAMPLEFORMAT, &amp;(this-&gt;_sampleFormat));</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (samplesPerPixel != 1) {</div><div class="line">        std::stringstream message;</div><div class="line">        message &lt;&lt; <span class="stringliteral">&quot;Tile Loader ERROR: The image is not greyscale: SamplesPerPixel = &quot;</span> &lt;&lt; samplesPerPixel</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;.&quot;</span>;</div><div class="line">        <span class="keyword">auto</span> messageChr = <span class="keyword">new</span> <span class="keywordtype">char</span>[message.str().length() + 1];</div><div class="line">        strcpy(messageChr, message.str().c_str());</div><div class="line">        <span class="keywordflow">throw</span> (FastImageException(messageChr));</div><div class="line">      }</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (_sampleFormat &lt; 1 &amp;&amp; _sampleFormat &gt; 3) {</div><div class="line">        _sampleFormat = 1;</div><div class="line">      }</div><div class="line"></div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">      std::stringstream message;</div><div class="line">      message &lt;&lt; <span class="stringliteral">&quot;Tile Loader ERROR: The image can not be opened.&quot;</span>;</div><div class="line">      <span class="keyword">auto</span> messageChr = <span class="keyword">new</span> <span class="keywordtype">char</span>[message.str().length() + 1];</div><div class="line">      strcpy(messageChr, message.str().c_str());</div><div class="line">      <span class="keywordflow">throw</span> (FastImageException(messageChr));</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  ~TiffTileLoader() {</div><div class="line">    <span class="keywordflow">if</span> (this-&gt;_tiff != <span class="keyword">nullptr</span>) {</div><div class="line">      TIFFClose(this-&gt;_tiff);</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Differents getter specific to the file format</span></div><div class="line">  std::string getName()<span class="keyword"> override </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;TIFF Tile Loader&quot;</span>; }</div><div class="line">  uint32_t getImageHeight(uint32_t level = 0)<span class="keyword"> const override </span>{ <span class="keywordflow">return</span> _imageHeight; }</div><div class="line">  uint32_t getImageWidth(uint32_t level = 0)<span class="keyword"> const override </span>{ <span class="keywordflow">return</span> _imageWidth; }</div><div class="line">  uint32_t getTileWidth(uint32_t level = 0)<span class="keyword"> const override </span>{ <span class="keywordflow">return</span> _tileWidth; }</div><div class="line">  uint32_t getTileHeight(uint32_t level = 0)<span class="keyword"> const override </span>{ <span class="keywordflow">return</span> _tileHeight; }</div><div class="line">  <span class="keywordtype">short</span> getBitsPerSample()<span class="keyword"> const override </span>{ <span class="keywordflow">return</span> _bitsPerSample; }</div><div class="line">  uint32_t getNbPyramidLevels()<span class="keyword"> const override </span>{ <span class="keywordflow">return</span> 1; }</div><div class="line"></div><div class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> FileType&gt;</div><div class="line">  <span class="keywordtype">void</span> loadTile(tdata_t src, UserType *dest) {</div><div class="line">    <span class="keywordflow">for</span> (uint32_t row = 0; row &lt; _tileHeight; ++row) {</div><div class="line">      <span class="keywordflow">for</span> (uint32_t col = 0; col &lt; _tileWidth; ++col) {</div><div class="line">        dest[row * _tileWidth + col] = (UserType) ((FileType *) (src))[row * _tileWidth + col];</div><div class="line">      }</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Load the tile from the file </span></div><div class="line">  <span class="keywordtype">double</span> loadTileFromFile(UserType *tile, uint32_t indexRowGlobalTile, uint32_t indexColGlobalTile)<span class="keyword"> override </span>{</div><div class="line">    tdata_t tiffTile = <span class="keyword">nullptr</span>;</div><div class="line">    tiffTile = _TIFFmalloc(TIFFTileSize(_tiff));</div><div class="line">    <span class="keyword">auto</span> begin = std::chrono::high_resolution_clock::now();</div><div class="line">    TIFFReadTile(_tiff, tiffTile, indexColGlobalTile * _tileWidth, indexRowGlobalTile * _tileHeight, 0, 0);</div><div class="line">    <span class="keyword">auto</span> end = std::chrono::high_resolution_clock::now();</div><div class="line">    <span class="keywordtype">double</span> diskDuration = (std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(end - begin).count());</div><div class="line">    std::stringstream message;</div><div class="line">    <span class="keywordflow">switch</span> (this-&gt;_sampleFormat) {</div><div class="line">      <span class="keywordflow">case</span> 1 :</div><div class="line">        <span class="keywordflow">switch</span> (this-&gt;_bitsPerSample) {</div><div class="line">          <span class="keywordflow">case</span> 8:loadTile&lt;uint8_t&gt;(tiffTile, tile);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          <span class="keywordflow">case</span> 16:loadTile&lt;uint16_t&gt;(tiffTile, tile);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          <span class="keywordflow">case</span> 32:loadTile&lt;uint32_t&gt;(tiffTile, tile);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          <span class="keywordflow">case</span> 64:loadTile&lt;uint64_t&gt;(tiffTile, tile);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          <span class="keywordflow">default</span>:</div><div class="line">            message &lt;&lt; <span class="stringliteral">&quot;Tile Loader ERROR: The data format is not supported for unsigned integer, &quot;</span></div><div class="line">                <span class="stringliteral">&quot;number bits per pixel = &quot;</span> &lt;&lt; this-&gt;_bitsPerSample;</div><div class="line">            <span class="keyword">auto</span> messageChr = <span class="keyword">new</span> <span class="keywordtype">char</span>[message.str().length() + 1];</div><div class="line">            strcpy(messageChr, message.str().c_str());</div><div class="line">            <span class="keywordflow">throw</span> (FastImageException(messageChr));</div><div class="line">        }</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      <span class="keywordflow">case</span> 2:</div><div class="line">        <span class="keywordflow">switch</span> (this-&gt;_bitsPerSample) {</div><div class="line">          <span class="keywordflow">case</span> 8:loadTile&lt;int8_t&gt;(tiffTile, tile);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          <span class="keywordflow">case</span> 16:loadTile&lt;int16_t&gt;(tiffTile, tile);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          <span class="keywordflow">case</span> 32:loadTile&lt;int32_t&gt;(tiffTile, tile);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          <span class="keywordflow">case</span> 64:loadTile&lt;int64_t&gt;(tiffTile, tile);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          <span class="keywordflow">default</span>:</div><div class="line">            message &lt;&lt; <span class="stringliteral">&quot;Tile Loader ERROR: The data format is not supported for signed integer, &quot;</span></div><div class="line">                <span class="stringliteral">&quot;number bits per pixel = &quot;</span> &lt;&lt; this-&gt;_bitsPerSample;</div><div class="line">            <span class="keyword">auto</span> messageChr = <span class="keyword">new</span> <span class="keywordtype">char</span>[message.str().length() + 1];</div><div class="line">            strcpy(messageChr, message.str().c_str());</div><div class="line">            <span class="keywordflow">throw</span> (FastImageException(messageChr));</div><div class="line">        }</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      <span class="keywordflow">case</span> 3:</div><div class="line">        <span class="keywordflow">switch</span> (this-&gt;_bitsPerSample) {</div><div class="line">          <span class="keywordflow">case</span> 8:loadTile&lt;float&gt;(tiffTile, tile);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          <span class="keywordflow">case</span> 16:loadTile&lt;float&gt;(tiffTile, tile);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          <span class="keywordflow">case</span> 32:loadTile&lt;float&gt;(tiffTile, tile);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          <span class="keywordflow">case</span> 64:loadTile&lt;double&gt;(tiffTile, tile);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          <span class="keywordflow">default</span>:</div><div class="line">            message &lt;&lt; <span class="stringliteral">&quot;Tile Loader ERROR: The data format is not supported for float, &quot;</span></div><div class="line">                <span class="stringliteral">&quot;number bits per pixel = &quot;</span> &lt;&lt; this-&gt;_bitsPerSample;</div><div class="line">            <span class="keyword">auto</span> messageChr = <span class="keyword">new</span> <span class="keywordtype">char</span>[message.str().length() + 1];</div><div class="line">            strcpy(messageChr, message.str().c_str());</div><div class="line">            <span class="keywordflow">throw</span> (FastImageException(messageChr));</div><div class="line">        }</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      <span class="keywordflow">default</span>:</div><div class="line">        message &lt;&lt; <span class="stringliteral">&quot;Tile Loader ERROR: The data format is not supported, sample format = &quot;</span></div><div class="line">                &lt;&lt; this-&gt;_sampleFormat;</div><div class="line">        <span class="keyword">auto</span> messageChr = <span class="keyword">new</span> <span class="keywordtype">char</span>[message.str().length() + 1];</div><div class="line">        strcpy(messageChr, message.str().c_str());</div><div class="line">        <span class="keywordflow">throw</span> (FastImageException(messageChr));</div><div class="line">    }</div><div class="line">    _TIFFfree(tiffTile);</div><div class="line">    <span class="keywordflow">return</span> diskDuration;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Copy the Tile Loader</span></div><div class="line">  ATileLoader&lt;UserType&gt; *copyTileLoader()<span class="keyword"> override </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> TiffTileLoader&lt;UserType&gt;(this-&gt;getNumThreads(), this-&gt;getFilePath(), *<span class="keyword">this</span>);</div><div class="line">  }</div><div class="line">};</div><div class="line">}</div></div><!-- fragment --><p>## Getting started </p><div class="fragment"><div class="line">The code in this section is only PSEUDOCODE, and is not meant to be executed as is.</div></div><!-- fragment --><h3>Image traversal</h3>
<p>Here a little program to go through all the pixel in a tiled greyscale tiff image: </p><div class="fragment"><div class="line"><span class="comment">// Tile loader creation depending on the image</span></div><div class="line"><a class="code" href="dc/d54/classfi_1_1ATileLoader.html">fi::ATileLoader&lt;uint32_t&gt;</a> *tileLoader = <span class="keyword">new</span> fi::TiffTileLoader&lt;uint32_t&gt;(pathImage); </div><div class="line"></div><div class="line"><span class="comment">// Fast Image accessor creation</span></div><div class="line"><span class="keyword">auto</span> *fi = <span class="keyword">new</span> <a class="code" href="dc/d6b/classfi_1_1FastImage.html">fi::FastImage&lt;uint32_t&gt;</a>(tileLoader, 0);</div><div class="line"></div><div class="line"><span class="comment">// Configure and run the Fast Image</span></div><div class="line">fi-&gt;<a class="code" href="dc/d6b/classfi_1_1FastImage.html#aa2ae5e5498f57462abd876108a55475c">configureAndRun</a>();</div><div class="line"></div><div class="line"><span class="comment">// Requesting all tiles </span></div><div class="line">fi-&gt;requestAllTiles(<span class="keyword">true</span>);</div><div class="line"></div><div class="line"><span class="comment">// Getting Data while Fast Image is processing some</span></div><div class="line"><span class="keywordflow">while</span> (fi-&gt;isGraphProcessingTiles()) {</div><div class="line"></div><div class="line">    <span class="comment">// Getting an image&#39;s view </span></div><div class="line">    <span class="keyword">auto</span> pView = fi-&gt;getAvailableViewBlocking();</div><div class="line"></div><div class="line">    <span class="comment">// If not the last one</span></div><div class="line">    <span class="keywordflow">if</span> (pView != <span class="keyword">nullptr</span>) {</div><div class="line"></div><div class="line">        <span class="comment">// Resolve shared_ptr</span></div><div class="line">        <span class="keyword">auto</span> view = pView-&gt;get();</div><div class="line">        <span class="comment">// Get information on the tile and looping through it </span></div><div class="line">        <span class="keywordflow">for</span> (int32_t r = 0; r &lt; view-&gt;getTileHeight(); ++r) {</div><div class="line">            <span class="keywordflow">for</span> (int32_t c = 0; c &lt; view-&gt;getTileWidth(); ++c) {</div><div class="line">                <span class="comment">// Getting the pixel</span></div><div class="line">                view-&gt;getPixel(r, c);</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// Release the memory</span></div><div class="line">        pView-&gt;releaseMemory();</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Waiting for FI to copmlete all it tasks</span></div><div class="line">fi-&gt;waitForGraphComplete();</div><div class="line"></div><div class="line"><span class="comment">// Delete Fast Image (it will take care of the Tile Loader)</span></div><div class="line"><span class="keyword">delete</span> fi;</div></div><!-- fragment --><h3>Spatial convolution</h3>
<p>This code do a spatial convolution on a tiled greyscale tiff image (kernel creation and tile writing are not showed). A full example is given in the fast image example. </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> radius = 6;</div><div class="line"><span class="keywordtype">float</span> pixelOut = 0;</div><div class="line"><span class="keywordtype">double</span> sigma = 2;</div><div class="line">int32_t sizeKernel = radius * 2 + 1;</div><div class="line"></div><div class="line"></div><div class="line"><a class="code" href="dc/d54/classfi_1_1ATileLoader.html">fi::ATileLoader&lt;uint32_t&gt;</a> *tileLoader = <span class="keyword">new</span> fi::TiffTileLoader&lt;uint32_t&gt;(pathImage); <span class="comment">// Tile loader creation depending on the image</span></div><div class="line"><span class="keyword">auto</span> *fi = <span class="keyword">new</span> <a class="code" href="dc/d6b/classfi_1_1FastImage.html">fi::FastImage&lt;uint32_t&gt;</a>(tileLoader, 0); <span class="comment">// Fast Image accessor creation</span></div><div class="line"></div><div class="line">std::vector&lt;double&gt; kernel = gaussian(radiusKernel, sigma); <span class="comment">// Kernel creation </span></div><div class="line"><span class="keyword">auto</span> *tileOut = <span class="keyword">new</span> <span class="keywordtype">float</span>[fi-&gt;getTileWidth() * fi-&gt;getTileHeight()]();</div><div class="line"></div><div class="line">fi-&gt;configureAndRun(); <span class="comment">// Configure and run the Fast Image</span></div><div class="line">fi-&gt;requestAllTiles(<span class="keyword">true</span>); <span class="comment">// Requesting all tiles </span></div><div class="line"></div><div class="line"><span class="comment">// Getting Data while Fast Image is processing some</span></div><div class="line"><span class="keywordflow">while</span> (fi-&gt;isGraphProcessingTiles()) {</div><div class="line">    <span class="keyword">auto</span> pView = fi-&gt;getAvailableViewBlocking(); <span class="comment">// Getting an image&#39;s view </span></div><div class="line">    <span class="comment">// If not the last one</span></div><div class="line">    <span class="keywordflow">if</span> (pView != <span class="keyword">nullptr</span>) {</div><div class="line"></div><div class="line">        <span class="keyword">auto</span> view = pView-&gt;get(); <span class="comment">// Resolve shared_ptr</span></div><div class="line">        <span class="comment">// Get information on the tile and looping through it </span></div><div class="line">        <span class="keywordflow">for</span> (int32_t r = 0; r &lt; view-&gt;getTileHeight(); ++r) {</div><div class="line">            <span class="keywordflow">for</span> (int32_t c = 0; c &lt; view-&gt;getTileWidth(); ++c) {</div><div class="line">                pixelOut = 0;</div><div class="line">                <span class="keywordflow">for</span> (int32_t rK = -radius; rK &lt;= radius; ++rK) {</div><div class="line">                    <span class="keywordflow">for</span> (int32_t cK = -radius; cK &lt;= radius; ++cK) {</div><div class="line">                        pixelOut += view-&gt;getPixel(r + rK, c + cK) * kernel[(rK + radius) * sizeKernel + (cK + radius)];</div><div class="line">                    }</div><div class="line">                }</div><div class="line">                tileOut[r * tileWidth + c] = pixelOut / (view-&gt;getTileHeight() * view-&gt;getTileWidth());</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        writeTile(tileOut, view-&gt;getGlobalXOffset(), view-&gt;getGlobalYOffset());</div><div class="line">        <span class="comment">// Release the memory</span></div><div class="line">        pView-&gt;releaseMemory();</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">delete</span> [] tileOut;</div><div class="line"><span class="keyword">delete</span> (fi)</div></div><!-- fragment --><h3>OpenCV convolution</h3>
<p>This code do a convolution with OpenCV on a tiled greyscale tiff image (kernel creation and tile writing are not showed). A full example is given in the fast image example. </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span>cv; </div><div class="line"></div><div class="line"><span class="keywordtype">int</span> radius = 6;</div><div class="line"><span class="keywordtype">float</span> pixelOut = 0;</div><div class="line"><span class="keywordtype">double</span> sigma = 2;</div><div class="line">int32_t sizeKernel = radius * 2 + 1;</div><div class="line"></div><div class="line"></div><div class="line"><a class="code" href="dc/d54/classfi_1_1ATileLoader.html">fi::ATileLoader&lt;uint32_t&gt;</a> *tileLoader = <span class="keyword">new</span> fi::TiffTileLoader&lt;uint32_t&gt;(pathImage); <span class="comment">// Tile loader creation depending on the image</span></div><div class="line"><span class="keyword">auto</span> *fi = <span class="keyword">new</span> <a class="code" href="dc/d6b/classfi_1_1FastImage.html">fi::FastImage&lt;uint32_t&gt;</a>(tileLoader, 0); <span class="comment">// Fast Image accessor creation</span></div><div class="line"></div><div class="line">Mat kernel = gaussian(radius, sigma, CV_32F); <span class="comment">// Kernel creation </span></div><div class="line"></div><div class="line"><span class="keyword">auto</span> *tileOut = <span class="keyword">new</span> <span class="keywordtype">float</span>[fi-&gt;getTileWidth() * fi-&gt;getTileHeight()]();</div><div class="line"></div><div class="line">fi-&gt;configureAndRun(); <span class="comment">// Configure and run the Fast Image</span></div><div class="line">fi-&gt;requestAllTiles(<span class="keyword">true</span>); <span class="comment">// Requesting all tiles </span></div><div class="line"></div><div class="line"><span class="keyword">auto</span> viewHeight = fi-&gt;getViewHeight();</div><div class="line"><span class="keyword">auto</span> viewWidth = fi-&gt;getViewWidth();</div><div class="line"></div><div class="line"><span class="comment">// Getting Data while Fast Image is processing some</span></div><div class="line"><span class="keywordflow">while</span> (fi-&gt;isGraphProcessingTiles()) {</div><div class="line">    <span class="keyword">auto</span> pView = fi-&gt;getAvailableViewBlocking(); <span class="comment">// Getting an image&#39;s view </span></div><div class="line">    <span class="comment">// If not the last one</span></div><div class="line">    <span class="keywordflow">if</span> (pView != <span class="keyword">nullptr</span>) {</div><div class="line">        <span class="keyword">auto</span> view = pView-&gt;get(); <span class="comment">// Resolve shared_ptr</span></div><div class="line"></div><div class="line">        Mat matInput(viewHeight, viewWidth, CV_32F, view-&gt;getData())</div><div class="line">        Mat tileResult;</div><div class="line"></div><div class="line">        <span class="comment">//Do the convolution</span></div><div class="line">        filter2D(matInput, tileResult, CV_32F, _kernel, cvPoint(-1, -1));</div><div class="line"></div><div class="line">        cv::Rect roi(radius, radius, view-&gt;getTileWidth(), view-&gt;getTileHeight());</div><div class="line">        cv::Mat&lt;float&gt; matOut = tileResult(roi).clone();</div><div class="line"></div><div class="line">        tileOut = (<span class="keywordtype">float</span> *)matOut.data;</div><div class="line"></div><div class="line">        writeTile(tileOut, view-&gt;getGlobalXOffset(), view-&gt;getGlobalYOffset());</div><div class="line">        <span class="comment">// Release the memory</span></div><div class="line">        pView-&gt;releaseMemory();</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">delete</span> [] tileOut;</div><div class="line"><span class="keyword">delete</span> (fi)</div></div><!-- fragment --><h3>Feature Collection usage</h3>
<p>This code go through a tiled greyscale tiff image (kernel creation and tile writing are not showed) through is mask. A full example is given in the fast image example. </p><div class="fragment"><div class="line"><a class="code" href="dc/d54/classfi_1_1ATileLoader.html">fi::ATileLoader&lt;uint32_t&gt;</a> *tileLoader = <span class="keyword">new</span> fi::TiffTileLoader&lt;uint32_t&gt;(pathImage); <span class="comment">// Tile loader creation depending on the image</span></div><div class="line"><span class="keyword">auto</span> *fi = <span class="keyword">new</span> <a class="code" href="dc/d6b/classfi_1_1FastImage.html">fi::FastImage&lt;uint32_t&gt;</a>(tileLoader, 0); <span class="comment">// Fast Image accessor creation</span></div><div class="line"></div><div class="line"><span class="comment">// Feature Collection creation </span></div><div class="line"><a class="code" href="d9/d78/classfc_1_1FeatureCollection.html">fc::FeatureCollection</a> featureCollection;</div><div class="line">featureCollection.deserialize(pathFeatureCollection);</div><div class="line"></div><div class="line">fi-&gt;<a class="code" href="dc/d6b/classfi_1_1FastImage.html#aa2ae5e5498f57462abd876108a55475c">configureAndRun</a>();</div><div class="line"></div><div class="line"><span class="comment">// Go through all features</span></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;feature : featureCollection) {</div><div class="line">    <span class="comment">// Request views from a feature</span></div><div class="line">    fi-&gt;requestFeature(feature);</div><div class="line">    <span class="keywordflow">while</span> (!fi-&gt;isFeatureDone()) {</div><div class="line">        <span class="keyword">auto</span> sh_view = fi-&gt;getAvailableViewBlocking();</div><div class="line">        <span class="keyword">auto</span> view = sh_view-&gt;get();</div><div class="line">        <span class="keywordflow">if</span> (view != <span class="keyword">nullptr</span>) {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keyword">auto</span> row = 0; row &lt; view-&gt;getTileHeight(); ++row) {</div><div class="line">                <span class="keywordflow">for</span> (<span class="keyword">auto</span> col = 0; col &lt; view-&gt;getTileWidth(); ++col) {</div><div class="line"></div><div class="line">                    <span class="comment">// Test is a pixel is in the bitmask</span></div><div class="line">                    <span class="keywordflow">if</span> (feature.isInBitMask(row + view-&gt;getGlobalYOffset(), col + view-&gt;getGlobalXOffset())) {</div><div class="line">                        view-&gt;getPixel(row, col);</div><div class="line">                    }</div><div class="line"></div><div class="line">                }</div><div class="line">            }</div><div class="line">            sh_view-&gt;releaseMemory();</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line">fi-&gt;finishedRequestingTiles();</div><div class="line"><span class="keyword">delete</span> fi;</div></div><!-- fragment --><h1>Credits</h1>
<p>Alexandre Bardakoff</p>
<p>Timothy Blattner</p>
<p>Walid Keyrouz</p>
<p>Mary Brady</p>
<h1>Contact Us</h1>
<p><a href="#" onclick="location.href='mai'+'lto:'+'ale'+'xa'+'ndr'+'e.'+'bar'+'da'+'kof'+'f@'+'nis'+'t.'+'gov'; return false;">Alexandre Bardakoff (alexandre.bardakoff ( at ) nist.gov</a></p>
<p><a href="#" onclick="location.href='mai'+'lto:'+'tim'+'ot'+'hy.'+'bl'+'att'+'ne'+'r@n'+'is'+'t.g'+'ov'; return false;">Timothy Blattner (timothy.blattner ( at ) nist.gov</a> </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
